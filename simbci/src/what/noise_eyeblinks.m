
function [noise,details,params] = noise_eyeblinks( sizeof, varargin )
	% Attempts to implement the BCI Comp IV review paper section 4.2.6: eye blinks

	% parse arguments
	p = inputParser;
	p.KeepUnmatched = false;
	p.CaseSensitive = true;
	p.PartialMatching = false;

	addParameter(p, 'dataset',                [],    @isstruct);
	addParameter(p, 'physicalModel',          core_head, @ishead);
	addParameter(p, 'mask',                   [],    @isnumeric); % when do the blinks occur?
	addParameter(p, 'eyeblinkStd1',           0.020, @isnumeric); % In seconds
	addParameter(p, 'eyeblinkStd2',           0.031, @isnumeric); % In seconds
	addParameter(p, 'eyeblinkAmplitude',      5,     @isnumeric);
	addParameter(p, 'visualize',              false, @islogical);

	p.parse(varargin{:});
	params = p.Results;

	%%%%%%%%%%%%%%

	samplingFreq = params.dataset.samplingFreq;

	noisePower = zeros(sizeof(1),1);
	
	% For each blink tick, append a blink noise power pattern.
	% Note that since this is added by convolution, the activity starts a bit before the event tag
	% @todo why not just modulate the mask and convolve the mask sequence?
	p1 = params.eyeblinkStd1;
	p2 = params.eyeblinkStd2;
	maxStd = max(p1,p2);
	sampleStep = 1 / samplingFreq;
	lp = -10*maxStd:sampleStep:10*maxStd;                       % assume 10 standard devs to both dirs is enough
	blinkIndexes = find(params.mask);
	blinkMaxPower=zeros(length(blinkIndexes),1);
	for i=1:length(blinkIndexes)
		pattern = (lp+randn(1)*p1).*exp( -(lp.^2)/(2.*p2.^2));		% "eye blink time course" of the paper
		thisBlink = zeros(sizeof(1),1);
		thisBlink(blinkIndexes(i)) = 1;
		noisePower = noisePower +  conv(thisBlink, pattern, 'same');
		blinkMaxPower(i) = max(abs(pattern(:)));
		%plot(lp, mask); xlabel('secs');
		%pause
	end
	% Although different blinks can have different power, make their
	% averate amplitude of the peaks roughly the one specified as parameter
	avgBlinkMaxPower = mean(blinkMaxPower);
	if(avgBlinkMaxPower>0)
		noisePower = noisePower .* (params.eyeblinkAmplitude ./ avgBlinkMaxPower);
	end

	if(params.physicalModel.constrainedOrientation)
		noiseMultiplier = ones([1 sizeof(2)]);
	else
		% If we're generating for a free dipole orientation case, weight directions differently
		assert(rem(sizeof(2),3)==0, 'Expected source count to be divisible by 3 in nonconstrained case');
		noiseMultiplier = repmat([1 0 10], [1 sizeof(2)/3]);
	end

	% Weight gaussian noise at the eye dipoles with the sampled power pattern. All other dipoles are 0.

	% @fixme, don't really understand what are the papers vertical and horizontal dipoles.
	% here its assumed leftEye is x y z and that z=vert, x=horiz.
	% here take 6 dims of random noise, 3 for each eye. Weight noise by the power from the timeline and then based if its
	% horizontal or vertical (10x vertical, 1x horiz) = noiseMultiplier. In the constrained orientation case, just 1 dim.
	noise = randn(sizeof) .* repmat(noisePower, [1 sizeof(2)]) .* repmat(noiseMultiplier , [sizeof(1) 1]);

	% n.b. blinks are already generated by mask, so we don't remask
	
	details = [];
	
	if(params.visualize)
		figure();
		yMax = max(noise(:));
		yMin = min(noise(:));

		for i=1:size(noise,2)
			subplot(size(noise,2),1,i);
			plot( (0:sizeof(1)-1)/samplingFreq, noise(:,i) );
			title(sprintf('Eyeblink artifacts: chn %d', i));
			ylim([yMin yMax]);
			xlabel('Time');ylabel('Amplitude');
		end

		drawnow;
	end

end

